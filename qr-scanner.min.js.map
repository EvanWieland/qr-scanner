{"version":3,"file":"qr-scanner.min.js","sources":["src/qr-scanner.js"],"sourcesContent":["export default class QrScanner {\n    /* async */\n    static hasCamera() {\n        // note that enumerateDevices can always be called and does not prompt the user for permission. However, device\n        // labels are only readable if served via https and an active media stream exists or permanent permission is\n        // given. That doesn't matter for us though as we don't require labels.\n        return navigator.mediaDevices.enumerateDevices()\n                        .then(devices => devices.some(device => device.kind === 'videoinput'))\n                        .catch(() => false);\n    }\n\n    constructor(video, onDecode, canvasSize = QrScanner.DEFAULT_CANVAS_SIZE) {\n        this.$video    = video;\n        this.$canvas   = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._active   = false;\n        this._paused   = false;\n\n        this.$canvas.width  = canvasSize;\n        this.$canvas.height = canvasSize;\n        this._sourceRect    = {\n            x     : 0,\n            y     : 0,\n            width : canvasSize,\n            height: canvasSize\n        };\n\n        this._onCanPlay          = this._onCanPlay.bind(this);\n        this._onPlay             = this._onPlay.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        this.$video.addEventListener('canplay', this._onCanPlay);\n        this.$video.addEventListener('play', this._onPlay);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrWorker = new Worker(QrScanner.WORKER_PATH);\n    }\n\n    destroy() {\n        this.$video.removeEventListener('canplay', this._onCanPlay);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        this._qrWorker.postMessage({\n            type: 'close'\n        });\n    }\n\n    /* async */\n    start() {\n        if (this._active && !this._paused) {\n            return Promise.resolve();\n        }\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n        this._active = true;\n        this._paused = false;\n        if (document.hidden) {\n            // camera will be started as soon as tab is in foreground\n            return Promise.resolve();\n        }\n        clearTimeout(this._offTimeout);\n        this._offTimeout = null;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return Promise.resolve();\n        }\n\n        let facingMode = 'environment';\n        return this._getCameraStream('environment', true)\n                   .catch(() => {\n                       // we (probably) don't have an environment camera\n                       facingMode = 'user';\n                       return this._getCameraStream(); // throws if camera is not accessible (e.g. due to not https)\n                   })\n                   .then(stream => {\n                       this.$video.srcObject = stream;\n                       this._setVideoMirror(facingMode);\n                   })\n                   .catch(e => {\n                       this._active = false;\n                       throw e;\n                   });\n    }\n\n    stop() {\n        this.pause();\n        this._active = false;\n    }\n\n    pause() {\n        this._paused = true;\n        if (!this._active) {\n            return;\n        }\n        this.$video.pause();\n        if (this._offTimeout) {\n            return;\n        }\n        this._offTimeout = setTimeout(() => {\n            const track = this.$video.srcObject && this.$video.srcObject.getTracks()[0];\n            if (!track) return;\n            track.stop();\n            this.$video.srcObject = null;\n            this._offTimeout      = null;\n        }, 300);\n    }\n\n    /* async */\n    static scanImage(imageOrFileOrUrl, sourceRect = null, worker = null, canvas = null, fixedCanvasSize = false,\n                     alsoTryWithoutSourceRect                                                           = false) {\n        let createdNewWorker = false;\n        let promise          = new Promise((resolve, reject) => {\n            if (!worker) {\n                worker           = new Worker(QrScanner.WORKER_PATH);\n                createdNewWorker = true;\n                worker.postMessage({type: 'inversionMode', data: 'both'}); // scan inverted color qr codes too\n            }\n            let timeout, onMessage, onError;\n            onMessage = event => {\n                const data = event.data;\n                if (data.data.type !== 'qrResult') {\n                    return;\n                }\n                worker.removeEventListener('message', onMessage);\n                worker.removeEventListener('error', onError);\n                clearTimeout(timeout);\n                if (data.data.data !== null) {\n                    // todo: come back to\n                    resolve(data.data.data, event);\n                } else {\n                    reject('QR code not found.');\n                }\n            };\n            onError   = (e) => {\n                worker.removeEventListener('message', onMessage);\n                worker.removeEventListener('error', onError);\n                clearTimeout(timeout);\n                const errorMessage = !e ? 'Unknown Error' : (e.message || e);\n                reject('Scanner error: ' + errorMessage);\n            };\n            worker.addEventListener('message', onMessage);\n            worker.addEventListener('error', onError);\n            timeout = setTimeout(() => onError('timeout'), 3000);\n            QrScanner._loadImage(imageOrFileOrUrl).then(image => {\n                const imageData = QrScanner._getImageData(image, sourceRect, canvas, fixedCanvasSize);\n                worker.postMessage({\n                    type: 'decode',\n                    data: imageData\n                }, [imageData.data.buffer]);\n            }).catch(onError);\n        });\n\n        if (sourceRect && alsoTryWithoutSourceRect) {\n            promise = promise.catch(() => QrScanner.scanImage(imageOrFileOrUrl, null, worker, canvas, fixedCanvasSize));\n        }\n\n        promise = promise.finally(() => {\n            if (!createdNewWorker) return;\n            worker.postMessage({\n                type: 'close'\n            });\n        });\n\n        return promise;\n    }\n\n    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n        this._qrWorker.postMessage({\n            type: 'grayscaleWeights',\n            data: {red, green, blue, useIntegerApproximation}\n        });\n    }\n\n    setInversionMode(inversionMode) {\n        this._qrWorker.postMessage({\n            type: 'inversionMode',\n            data: inversionMode\n        });\n    }\n\n    _onCanPlay() {\n        this._updateSourceRect();\n        this.$video.play();\n    }\n\n    _onPlay() {\n        this._updateSourceRect();\n        this._scanFrame();\n    }\n\n    _onVisibilityChange() {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    _updateSourceRect() {\n        const smallestDimension = Math.min(this.$video.videoWidth, this.$video.videoHeight);\n        const sourceRectSize    = Math.round(2 / 3 * smallestDimension);\n        this._sourceRect.width  = this._sourceRect.height = sourceRectSize;\n        this._sourceRect.x      = (this.$video.videoWidth - sourceRectSize) / 2;\n        this._sourceRect.y      = (this.$video.videoHeight - sourceRectSize) / 2;\n    }\n\n    _scanFrame() {\n        if (!this._active || this.$video.paused || this.$video.ended) return false;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(() => {\n            QrScanner.scanImage(this.$video, this._sourceRect, this._qrWorker, this.$canvas, true)\n                     .then(this._onDecode, error => {\n                         if (this._active && error !== 'QR code not found.') {\n                             console.error(error);\n                         }\n                     })\n                     .then(() => this._scanFrame());\n        });\n    }\n\n    _getCameraStream(facingMode, exact = false) {\n        const constraintsToTry = [{\n            width: {min: 1024}\n        }, {\n            width: {min: 768}\n        }, {}];\n\n        if (facingMode) {\n            if (exact) {\n                facingMode = {exact: facingMode};\n            }\n            constraintsToTry.forEach(constraint => constraint.facingMode = facingMode);\n        }\n        return this._getMatchingCameraStream(constraintsToTry);\n    }\n\n    _getMatchingCameraStream(constraintsToTry) {\n        if (constraintsToTry.length === 0) {\n            return Promise.reject('Camera not found.');\n        }\n        return navigator.mediaDevices.getUserMedia({\n            video: constraintsToTry.shift()\n        }).catch(() => this._getMatchingCameraStream(constraintsToTry));\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor           = facingMode === 'user' ? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    static _getImageData(image, sourceRect = null, canvas = null, fixedCanvasSize = false) {\n        canvas                 = canvas || document.createElement('canvas');\n        const sourceRectX      = sourceRect && sourceRect.x ? sourceRect.x : 0;\n        const sourceRectY      = sourceRect && sourceRect.y ? sourceRect.y : 0;\n        const sourceRectWidth  = sourceRect && sourceRect.width ? sourceRect.width : image.width || image.videoWidth;\n        const sourceRectHeight = sourceRect && sourceRect.height ? sourceRect.height : image.height || image.videoHeight;\n        if (!fixedCanvasSize && (canvas.width !== sourceRectWidth || canvas.height !== sourceRectHeight)) {\n            canvas.width  = sourceRectWidth;\n            canvas.height = sourceRectHeight;\n        }\n        const context                 = canvas.getContext('2d', {alpha: false});\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(image, sourceRectX, sourceRectY, sourceRectWidth, sourceRectHeight, 0, 0, canvas.width, canvas.height);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    /* async */\n    static _loadImage(imageOrFileOrUrl) {\n        if (imageOrFileOrUrl instanceof HTMLCanvasElement || imageOrFileOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrUrl instanceof window.OffscreenCanvas) {\n            return Promise.resolve(imageOrFileOrUrl);\n        } else if (imageOrFileOrUrl instanceof Image) {\n            return QrScanner._awaitImageLoad(imageOrFileOrUrl).then(() => imageOrFileOrUrl);\n        } else if (imageOrFileOrUrl instanceof File || imageOrFileOrUrl instanceof URL\n            || typeof (imageOrFileOrUrl) === 'string') {\n            const image = new Image();\n            if (imageOrFileOrUrl instanceof File) {\n                image.src = URL.createObjectURL(imageOrFileOrUrl);\n            } else {\n                image.src = imageOrFileOrUrl;\n            }\n            return QrScanner._awaitImageLoad(image).then(() => {\n                if (imageOrFileOrUrl instanceof File) {\n                    URL.revokeObjectURL(image.src);\n                }\n                return image;\n            });\n        } else {\n            return Promise.reject('Unsupported image type.');\n        }\n    }\n\n    /* async */\n    static _awaitImageLoad(image) {\n        return new Promise((resolve, reject) => {\n            if (image.complete && image.naturalWidth !== 0) {\n                // already loaded\n                resolve();\n            } else {\n                let onLoad, onError;\n                onLoad  = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    resolve();\n                };\n                onError = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    reject('Image load error');\n                };\n                image.addEventListener('load', onLoad);\n                image.addEventListener('error', onError);\n            }\n        });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.WORKER_PATH         = 'qr-scanner-worker.min.js';\n"],"names":["QrScanner","navigator","mediaDevices","enumerateDevices","then","devices","some","device","kind","catch","video","onDecode","canvasSize","DEFAULT_CANVAS_SIZE","$video","$canvas","document","createElement","_onDecode","_paused","_active","width","height","_sourceRect","x","y","_onCanPlay","bind","_onPlay","_onVisibilityChange","addEventListener","_qrWorker","Worker","WORKER_PATH","removeEventListener","stop","postMessage","type","Promise","resolve","window","location","protocol","console","warn","hidden","clearTimeout","_offTimeout","srcObject","play","facingMode","_getCameraStream","stream","_setVideoMirror","e","pause","setTimeout","track","imageOrFileOrUrl","sourceRect","worker","canvas","fixedCanvasSize","alsoTryWithoutSourceRect","createdNewWorker","promise","reject","data","timeout","onMessage","onError","event","_loadImage","image","imageData","buffer","scanImage","finally","red","green","blue","useIntegerApproximation","inversionMode","_updateSourceRect","_scanFrame","start","videoHeight","sourceRectSize","videoWidth","paused","ended","requestAnimationFrame","error","exact","min","constraintsToTry","forEach","constraint","_getMatchingCameraStream","length","getUserMedia","shift","style","transform","sourceRectWidth","sourceRectHeight","context","imageSmoothingEnabled","drawImage","sourceRectX","sourceRectY","getImageData","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","OffscreenCanvas","Image","_awaitImageLoad","File","URL","src","createObjectURL","revokeObjectURL","complete","naturalWidth","onLoad"],"mappings":"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"}